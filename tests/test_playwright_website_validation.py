#!/usr/bin/env python3
"""Automated Playwright website validation tests.

This module implements GitHub issue #103: Automated Playwright website validation.
It validates all pages, navigation, theme toggle, year selector, and data visualizations.

Requirements:
    - Playwright must be installed: pip install playwright && playwright install
    - Local HTTP server must be running on port 8888

Usage:
    # Start HTTP server first
    cd site/2024 && python -m http.server 8888 --bind 127.0.0.1 &

    # Run tests
    pytest tests/test_playwright_website_validation.py -v

    # Run with headed browser (see what's happening)
    pytest tests/test_playwright_website_validation.py -v --headed
"""

import re

import pytest

# Check if playwright is available
try:
    from playwright.sync_api import Page, expect
    HAS_PLAYWRIGHT = True
except ImportError:
    HAS_PLAYWRIGHT = False
    Page = None  # type: ignore
    expect = None  # type: ignore

# Skip all tests in this module if playwright is not installed
pytestmark = pytest.mark.skipif(
    not HAS_PLAYWRIGHT,
    reason="Playwright not installed. Run: pip install playwright && playwright install"
)


# Base URL for local testing
BASE_URL = "http://127.0.0.1:8888"

# All pages that should be validated
PAGES = [
    "index.html",
    "summary.html",
    "engineers.html",
    "leaderboards.html",
    "repos.html",
    "awards.html",
]


@pytest.fixture(scope="session")
def browser_context_args(browser_context_args):
    """Configure browser context for tests."""
    return {
        **browser_context_args,
        "viewport": {"width": 1920, "height": 1080},
    }


class TestPageLoading:
    """Test that all pages load correctly."""

    @pytest.mark.parametrize("page_name", PAGES)
    def test_page_loads_successfully(self, page: Page, page_name: str):
        """Verify page loads with 200 status and has expected title."""
        response = page.goto(f"{BASE_URL}/{page_name}")

        # Check HTTP status
        assert response is not None, f"No response for {page_name}"
        assert response.status == 200, f"{page_name} returned {response.status}"

        # Check page title contains expected text
        expect(page).to_have_title(re.compile("Sample Org Year in Review 2024"))

    @pytest.mark.parametrize("page_name", PAGES)
    def test_page_has_header(self, page: Page, page_name: str):
        """Verify each page has the site header."""
        page.goto(f"{BASE_URL}/{page_name}")

        # Check for header elements
        header = page.locator("header.site-header")
        expect(header).to_be_visible()

        # Check header contains org name
        expect(header.locator(".site-title")).to_contain_text("Sample Org Year in Review 2024")

    @pytest.mark.parametrize("page_name", PAGES)
    def test_page_has_navigation(self, page: Page, page_name: str):
        """Verify each page has the sidebar navigation."""
        page.goto(f"{BASE_URL}/{page_name}")

        # Check for sidebar navigation
        nav = page.locator("aside.sidebar nav.main-nav")
        expect(nav).to_be_visible()

        # Check for expected nav links
        nav_links = nav.locator("a.nav-link")
        expect(nav_links).to_have_count(6)  # 6 main pages

    @pytest.mark.parametrize("page_name", PAGES)
    def test_page_has_footer(self, page: Page, page_name: str):
        """Verify each page has the site footer."""
        page.goto(f"{BASE_URL}/{page_name}")

        # Check for footer
        footer = page.locator("footer.site-footer")
        expect(footer).to_be_visible()

        # Check footer contains generation info
        expect(footer).to_contain_text("Generated by gh-year-end")


class TestYearSelector:
    """Test year selector dropdown functionality."""

    def test_year_selector_visible(self, page: Page):
        """Verify year selector is visible on page."""
        page.goto(f"{BASE_URL}/index.html")

        year_toggle = page.locator("#yearToggle")
        expect(year_toggle).to_be_visible()
        expect(year_toggle).to_contain_text("2024")

    def test_year_selector_toggle(self, page: Page):
        """Verify year selector dropdown opens and closes."""
        page.goto(f"{BASE_URL}/index.html")

        year_toggle = page.locator("#yearToggle")
        year_dropdown = page.locator("#yearDropdown")

        # Initially dropdown should be hidden
        expect(year_dropdown).to_have_attribute("aria-hidden", "true")

        # Click to open dropdown
        year_toggle.click()

        # Wait for dropdown to be visible
        expect(year_dropdown).to_have_attribute("aria-hidden", "false")

        # Click again to close
        year_toggle.click()

        # Dropdown should be hidden again
        expect(year_dropdown).to_have_attribute("aria-hidden", "true")

    def test_year_selector_has_options(self, page: Page):
        """Verify year selector has year options."""
        page.goto(f"{BASE_URL}/index.html")

        # Open dropdown
        page.locator("#yearToggle").click()

        # Check for year options
        year_options = page.locator(".year-dropdown .year-option")
        count = year_options.count()
        assert count >= 2, f"Expected at least 2 year options, found {count}"

        # Check current year is marked as active
        active_option = page.locator(".year-option.active")
        expect(active_option).to_be_visible()
        expect(active_option).to_contain_text("2024")


class TestThemeToggle:
    """Test theme toggle (light/dark mode) functionality."""

    def test_theme_toggle_button_visible(self, page: Page):
        """Verify theme toggle button is visible."""
        page.goto(f"{BASE_URL}/index.html")

        theme_toggle = page.locator("button.theme-toggle")
        expect(theme_toggle).to_be_visible()

    def test_theme_toggle_switches_modes(self, page: Page):
        """Verify theme toggle switches between light and dark modes."""
        page.goto(f"{BASE_URL}/index.html")

        html_element = page.locator("html")
        theme_toggle = page.locator("button.theme-toggle")

        # Initially should be light mode
        expect(html_element).to_have_attribute("data-theme", "light")

        # Click to switch to dark mode
        theme_toggle.click()

        # Should now be dark mode
        expect(html_element).to_have_attribute("data-theme", "dark")

        # Click to switch back to light mode
        theme_toggle.click()

        # Should be light mode again
        expect(html_element).to_have_attribute("data-theme", "light")

    def test_theme_persists_across_pages(self, page: Page):
        """Verify theme preference persists when navigating to another page."""
        page.goto(f"{BASE_URL}/index.html")

        # Switch to dark mode
        page.locator("button.theme-toggle").click()

        # Navigate to another page
        page.goto(f"{BASE_URL}/repos.html")

        # Theme should still be dark
        html_element = page.locator("html")
        expect(html_element).to_have_attribute("data-theme", "dark")


class TestNavigation:
    """Test navigation between pages."""

    def test_sidebar_navigation_links(self, page: Page):
        """Verify all sidebar navigation links work."""
        page.goto(f"{BASE_URL}/index.html")

        # Get all nav links
        nav_links = page.locator("aside.sidebar nav.main-nav a.nav-link")

        # Expected links and their targets
        expected_links = {
            "Overview": "index.html",
            "Executive Summary": "summary.html",
            "Contributors": "engineers.html",
            "Leaderboards": "leaderboards.html",
            "Repositories": "repos.html",
            "Awards": "awards.html",
        }

        for link_text, expected_href in expected_links.items():
            link = nav_links.filter(has_text=link_text)
            expect(link).to_have_attribute("href", expected_href)

    def test_navigation_to_each_page(self, page: Page):
        """Verify navigation to each page via sidebar links."""
        page.goto(f"{BASE_URL}/index.html")

        # Navigate to each page via sidebar
        pages_to_test = [
            ("repos.html", "Repositories"),
            ("awards.html", "Awards"),
            ("index.html", "Overview"),
        ]

        for page_href, _page_keyword in pages_to_test:
            # Click the link
            page.locator(f"aside.sidebar nav.main-nav a.nav-link[href='{page_href}']").click()

            # Verify URL
            expect(page).to_have_url(re.compile(f".*{page_href}"))

            # Verify page loaded (check for main content)
            expect(page.locator("main.content")).to_be_visible()

    def test_active_nav_link_highlights(self, page: Page):
        """Verify active navigation link is highlighted."""
        page.goto(f"{BASE_URL}/index.html")

        # Overview link should be active
        active_link = page.locator("aside.sidebar nav.main-nav a.nav-link.active")
        expect(active_link).to_be_visible()
        expect(active_link).to_have_attribute("href", "index.html")


class TestDataVisualizations:
    """Test that data visualizations render correctly."""

    def test_index_page_stat_cards(self, page: Page):
        """Verify overview page has stat cards with data."""
        page.goto(f"{BASE_URL}/index.html")

        # Check for stat cards
        stat_cards = page.locator(".stat-card")
        expect(stat_cards).to_have_count(4)  # 4 main stat cards on overview

        # Check each card has a value
        for i in range(4):
            card = stat_cards.nth(i)
            stat_value = card.locator(".stat-value")
            expect(stat_value).to_be_visible()

            # Value should not be empty
            value_text = stat_value.text_content()
            assert value_text and value_text.strip() != "", f"Stat card {i} has empty value"

    def test_index_page_highlights(self, page: Page):
        """Verify overview page has highlight cards."""
        page.goto(f"{BASE_URL}/index.html")

        # Check for highlight cards
        highlight_cards = page.locator(".highlight-card")
        expect(highlight_cards).to_have_count(4)  # 4 highlights expected

        # Each should have a title and value
        for i in range(4):
            card = highlight_cards.nth(i)
            expect(card.locator("h3")).to_be_visible()
            expect(card.locator(".highlight-value")).to_be_visible()

    def test_index_page_activity_chart(self, page: Page):
        """Verify overview page renders activity chart."""
        page.goto(f"{BASE_URL}/index.html")

        # Wait for D3 to load and render
        page.wait_for_load_state("networkidle")
        page.wait_for_timeout(2000)  # Give D3 time to render

        # Check for chart container
        chart_container = page.locator("#chart-activity-timeline")
        expect(chart_container).to_be_visible()

        # Check that SVG was rendered by D3
        svg = chart_container.locator("svg")
        expect(svg).to_be_visible()

    def test_leaderboards_page_has_tables(self, page: Page):
        """Verify leaderboards page has data tables."""
        page.goto(f"{BASE_URL}/leaderboards.html")

        # Wait for page to load
        page.wait_for_load_state("networkidle")

        # Check for leaderboard sections
        # Note: Exact structure depends on implementation
        # Looking for common table/list elements
        main_content = page.locator("main.content")
        expect(main_content).to_be_visible()

    def test_repos_page_has_content(self, page: Page):
        """Verify repositories page has repo information."""
        page.goto(f"{BASE_URL}/repos.html")

        # Wait for page to load
        page.wait_for_load_state("networkidle")

        # Check for main content
        main_content = page.locator("main.content")
        expect(main_content).to_be_visible()

    def test_awards_page_has_content(self, page: Page):
        """Verify awards page has award information."""
        page.goto(f"{BASE_URL}/awards.html")

        # Wait for page to load
        page.wait_for_load_state("networkidle")

        # Check for main content
        main_content = page.locator("main.content")
        expect(main_content).to_be_visible()


class TestResponsiveness:
    """Test responsive design and mobile views."""

    def test_mobile_viewport(self, page: Page):
        """Verify site is usable on mobile viewport."""
        # Set mobile viewport
        page.set_viewport_size({"width": 375, "height": 667})
        page.goto(f"{BASE_URL}/index.html")

        # Header should still be visible
        header = page.locator("header.site-header")
        expect(header).to_be_visible()

        # Main content should be visible
        main_content = page.locator("main.content")
        expect(main_content).to_be_visible()

    def test_tablet_viewport(self, page: Page):
        """Verify site is usable on tablet viewport."""
        # Set tablet viewport
        page.set_viewport_size({"width": 768, "height": 1024})
        page.goto(f"{BASE_URL}/index.html")

        # All main elements should be visible
        expect(page.locator("header.site-header")).to_be_visible()
        expect(page.locator("main.content")).to_be_visible()


class TestAccessibility:
    """Test accessibility features."""

    def test_theme_toggle_has_aria_label(self, page: Page):
        """Verify theme toggle has proper aria label."""
        page.goto(f"{BASE_URL}/index.html")

        theme_toggle = page.locator("button.theme-toggle")
        expect(theme_toggle).to_have_attribute("aria-label", re.compile(".*dark.*mode.*", re.IGNORECASE))

    def test_year_selector_has_aria_attributes(self, page: Page):
        """Verify year selector has proper aria attributes."""
        page.goto(f"{BASE_URL}/index.html")

        year_toggle = page.locator("#yearToggle")
        expect(year_toggle).to_have_attribute("aria-label", re.compile(".*year.*", re.IGNORECASE))
        # Check aria-expanded exists (value can be "true" or "false")
        aria_expanded = year_toggle.get_attribute("aria-expanded")
        assert aria_expanded in ["true", "false"], f"aria-expanded should be 'true' or 'false', got {aria_expanded}"

    def test_nav_has_aria_label(self, page: Page):
        """Verify navigation has proper aria label."""
        page.goto(f"{BASE_URL}/index.html")

        nav = page.locator("aside.sidebar nav.main-nav")
        expect(nav).to_have_attribute("aria-label", re.compile(".*[Nn]avigation.*"))


class TestViewToggle:
    """Test executive vs engineer view toggle."""

    def test_view_toggle_buttons_visible(self, page: Page):
        """Verify view toggle buttons are visible."""
        page.goto(f"{BASE_URL}/index.html")

        view_toggle = page.locator(".view-toggle")
        expect(view_toggle).to_be_visible()

        # Should have exec and engineer buttons
        exec_btn = view_toggle.locator("button[data-view='exec']")
        engineer_btn = view_toggle.locator("button[data-view='engineer']")

        expect(exec_btn).to_be_visible()
        expect(engineer_btn).to_be_visible()

    def test_view_toggle_switches_views(self, page: Page):
        """Verify view toggle switches between exec and engineer views."""
        page.goto(f"{BASE_URL}/index.html")

        exec_btn = page.locator("button[data-view='exec']")
        engineer_btn = page.locator("button[data-view='engineer']")

        # Initially engineer view should be active
        expect(engineer_btn).to_have_class(re.compile(".*active.*"))

        # Click exec view
        exec_btn.click()

        # Exec view should now be active
        expect(exec_btn).to_have_class(re.compile(".*active.*"))

        # Click engineer view
        engineer_btn.click()

        # Engineer view should be active again
        expect(engineer_btn).to_have_class(re.compile(".*active.*"))


class TestErrorHandling:
    """Test error handling and edge cases."""

    def test_missing_page_returns_404(self, page: Page):
        """Verify accessing non-existent page returns 404."""
        response = page.goto(f"{BASE_URL}/nonexistent.html")
        assert response is not None
        assert response.status == 404

    def test_page_loads_without_javascript_errors(self, page: Page):
        """Verify pages load without JavaScript console errors."""
        errors = []
        page.on("pageerror", lambda error: errors.append(error))

        page.goto(f"{BASE_URL}/index.html")
        page.wait_for_load_state("networkidle")

        # Allow some time for any delayed errors
        page.wait_for_timeout(2000)

        # Should not have any uncaught errors
        assert len(errors) == 0, f"Page has JavaScript errors: {errors}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
