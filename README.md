# gh-year-end

CLI tool for generating GitHub year-end community health reports.

Collects activity data from GitHub organizations or users, runs analytics, and builds a static site with D3.js visualizations for executive summary and engineer drilldown views.

## Quick Start

Install with uv:

```bash
git clone https://github.com/williamzujkowski/yakshave.git
cd yakshave
uv sync
```

Set your GitHub token:

```bash
export GITHUB_TOKEN=ghp_your_token_here
```

Configure for your org or user:

```bash
cp config/config.example.yaml config/config.yaml
# Edit config.yaml - set target.mode (org|user) and target.name
```

Run the pipeline:

```bash
uv run gh-year-end all --config config/config.yaml
```

View the report:

```bash
# Note: Year directory (e.g., 2025) is set in config.yaml
python -m http.server -d site/2025
# Open http://localhost:8000
```

## CLI Commands

### collect

Collects GitHub data and generates metrics JSON in a single pass. This performs:
1. Discovery of all repositories in the target org/user
2. Collection of PRs, issues, reviews, comments, commits, and hygiene data
3. In-memory metric aggregation
4. Export of final JSON files to `site/{year}/data/`

```bash
uv run gh-year-end collect --config config.yaml

# Flags:
#   --force           Re-fetch data even if cached
#   --resume          Resume from last checkpoint
#   --retry-failed    Retry repos that failed previously
#   --from-repo NAME  Resume from specific repository
```

Output files: `summary.json`, `leaderboards.json`, `timeseries.json`, `repo_health.json`, `hygiene_scores.json`, `awards.json`

### build

Builds static HTML site from the metrics JSON files generated by `collect`. Renders Jinja2 templates with D3.js visualizations and creates a complete static site in `site/{year}/`.

```bash
uv run gh-year-end build --config config.yaml
```

The site includes:
- Executive summary dashboard
- Contributor leaderboards
- Repository health metrics
- Interactive D3.js visualizations
- Time series activity charts

### all

Runs the complete pipeline: collect data and build site. This is equivalent to running `collect` followed by `build`.

```bash
uv run gh-year-end all --config config.yaml

# Flags:
#   --force    Re-fetch data even if it already exists
```

Use `--verbose` on root command: `uv run gh-year-end --verbose collect --config config.yaml`

## Features

**Single-Pass Collection**: Collects GitHub data and computes metrics in a single pass with in-memory aggregation. No intermediate files or multi-stage pipeline required.

**Pre-filtering for Large Orgs**: If enabled, uses GitHub Search API to pre-filter repos based on activity, size, language, topics, and name patterns. Reduces API calls for orgs with 150+ repositories.

**Adaptive Rate Limiting**: Respects `retry-after` headers, sleeps when `x-ratelimit-remaining` hits zero, and samples `/rate_limit` endpoint periodically. Avoids secondary rate limits with configurable concurrency and pacing.

**Bot Detection**: Filters bot accounts from leaderboards based on regex patterns (`.*\[bot\]$`, `dependabot`, etc.). Supports override list for bot accounts that should count as human contributors.

**Multiple Report Views**: Executive summary (high-level metrics) and engineer drilldown (detailed activity, commit analysis, file changes).

## Data Pipeline

```
GitHub API → In-Memory Aggregation → Metrics JSON → Static Site
             (collect)                               (build)
```

### collect

Performs end-to-end data collection and metric computation in a single pass:

1. **Discovery**: Finds all repositories in the target org/user
2. **Collection**: Fetches repos, pull requests, issues, reviews, comments, commits, and hygiene data (file presence, branch protection, security features)
3. **Aggregation**: Applies bot detection, identity resolution, and computes metrics in-memory
4. **Export**: Writes final JSON files to `site/{year}/data/`

Metrics computed:
- Leaderboards (PRs merged, reviews submitted, docs changes, etc.)
- Time series (weekly activity)
- Repository health (PR review coverage, staleness, response times)
- Hygiene scores (SECURITY.md, CODEOWNERS, CI workflows, branch protection)
- Awards (top contributors with customizable categories)

### build

Generates the static site from metrics JSON:

1. Reads JSON files from `site/{year}/data/`
2. Renders Jinja2 templates with D3.js visualizations
3. Copies static assets (CSS, JS, fonts)
4. Outputs self-contained HTML/CSS/JS site in `site/{year}/`

The final site has no external dependencies and can be served with any static web server or deployed to GitHub Pages.

## Configuration

See `config/config.example.yaml` for all options.

Key settings:

```yaml
github:
  target:
    mode: org          # org | user
    name: your-org
  windows:
    year: 2025
    since: "2025-01-01T00:00:00Z"
    until: "2026-01-01T00:00:00Z"

identity:
  humans_only: true    # Filter bots from leaderboards

collection:
  enable:
    pulls: true
    issues: true
    reviews: true
    comments: true
    commits: true
    hygiene: true
```

Optional pre-filtering (reduces API calls for large orgs):

```yaml
github:
  discovery:
    quick_scan:
      enabled: true    # Use Search API for pre-filtering
    filters:
      activity:
        enabled: true
        min_pushed_at_days_ago: 365
      size:
        enabled: true
        min_kb: 1
```

## Development

Run tests:

```bash
uv run pytest
```

Run with coverage:

```bash
uv run pytest --cov=src/gh_year_end --cov-report=term-missing
```

Lint and format:

```bash
uv run ruff check .
uv run ruff format .
```

Type check:

```bash
uv run mypy src/
```

Pre-commit checks:

```bash
ruff check . && ruff format --check . && mypy src/ && pytest
```

## License

MIT
